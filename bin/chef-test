#!/usr/bin/env ruby
require 'pathname'
app_path = File.expand_path('../../', Pathname.new(__FILE__).realpath)
log_path = "#{app_path}/logs"
gem_file = "#{app_path}/Gemfile"
ENV['BUNDLE_GEMFILE'] ||= gem_file
require 'bundler/setup'

require 'chef/config'
require 'simple_config'
require 'mixlib/cli'
require 'chef/knife'
require 'logger'
require 'fileutils'

require 'env'
require 'cookbooks'
require 'node'
require 'colorize'

logger = Logger.new(STDOUT)
logger.formatter = proc do |severity, datetime, _progname, msg|
  date_format = datetime.strftime('%Y-%m-%d %H:%M:%S')
  if severity == 'INFO'
    "[#{date_format}] [#{severity}] #{msg}\n".green
  elsif severity == 'WARN'
    "[#{date_format}] [#{severity}] #{msg}\n".red
  else
    "[#{date_format}] [#{severity}] #{msg}\n"
  end
end

# Vars
branch = SimpleConfig.git.branch.match(%r{origin/(.*)})[1]
pwd = Dir.pwd

# Get cookbooks
logger.info("Git: clone #{SimpleConfig.git.url} branch #{branch}")
cookbooks = Cookbooks.get_changes(SimpleConfig.git.url, SimpleConfig.git.commit)

logger.info("Cookbooks: Find changes in: #{cookbooks}")
skipped_cookbooks = cookbooks.reject { |c| File.exist?("cookbooks/#{c}/ci.yml") }
cookbooks.select! { |c| File.exist?("cookbooks/#{c}/ci.yml") }
logger.info("Cookbooks: test #{cookbooks}") if cookbooks.any?
logger.warn("Cookbooks: skip #{skipped_cookbooks}") if skipped_cookbooks.any?

nodes = []
threads = []
if cookbooks.any?
  # Create environment
  chef_env = Env.new
  chef_env.create
  logger.info("Chef: create environment #{chef_env.name}")

  # Update environment
  logger.info("Berks: update #{chef_env.name} environment from #{branch}")
  Dir.chdir 'berks'
  chef_env.update(branch, cookbooks)
  logger.info("Berks: created environment #{chef_env.name}")
  chef_env.show
  Dir.chdir pwd

  # NodeUp/Down
  cookbooks.each do |cookbook|
    config = YAML.load(File.read("cookbooks/#{cookbook}/ci.yml"))
    config['chef']['env'] = chef_env.name
    config['maintain'] = true
    logger.info("Deploy: using cookbook #{cookbook} with config: #{config}")
    node = Node.new
    threads << Thread.new do
      node.create SimpleConfig::Config.new.get_struct config
      File.write("#{log_path}/#{node.name}.log", node.output)
      nodes.push node
      node.delete
    end
  end
  threads.each(&:join)
  # Delete environment
  logger.info("Chef: delete environment #{chef_env.name}")
  chef_env.delete
else
  logger.info('Skip testing: no changes.')
end

deployed = nodes.select(&:status)
rejected = nodes.reject(&:status)

logger.info 'Passed the following nodes:' if deployed.any?
deployed.each { |node| logger.info node.name }

logger.warn 'Failed the following nodes:' if rejected.any?
rejected.each do |node|
  logger.warn node.name
end

exit 1 if rejected.any?
